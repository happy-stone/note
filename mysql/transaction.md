<h1 id='transaction'><a href="#transaction"> 事务 </a></h1>

1. 启动事务  `start transaction` 或者 `begin`；
2. 执行相关操作；
3. 完成事务并提交 `commit`; 或者 `rollback` 中止事务。

⚠️ 1. autocommit 默认是 on，除了明确 begin 开头表示事务之外，每次提交语句都会自动执行。

⚠️ 2. `craete`、`drop`、`alter` 等数据库操作语句（DDL）是无法回滚的。

#### 保存点 ####

`savepoint` 语句可以创建保存点，当事务需要回归的时候，可以回滚到保存点，不必回到原始状态。

#### 隔离级别 ####

当多个事务同时发送时，隔离级别定义了事务和其他事务在资源或者数据修改方面的的隔离程度。可以通过 `transaction_isolation` 设置隔离级别。

1. 读取未提交（read uncommitted）

    当前事务可以读取另一个事务写入但还未提交的数据，也称为 **脏读**。

2. 读提交（read committed）

    当前事务只能读取另一个事务提交的数据，也称为 **不可重复读**。

3. 可重复读（repeatable read）

    一个事务通过第一条语句只能看到相同的数据，即使另一个事务已经提交数据。在同一个事务中，读取通过第一次读取建立快照，后面读取的是快照的数据。

4. 序列化（serializable）

    把选定的行锁起来，序列化提供最高级别的隔离。序列化会等待被锁的行，并且总是读取最新提交的数据。


<h1 id='lock'><a href="#lock"> 锁 </a></h1>

#### 内部锁 ####

MySQL 在自身服务器内部执行内部锁，管理过个会话对表内容的争用。

1. 行级锁

    细粒度锁，只有被访问的行会被锁定，允许通过多个会话同时进行写访问。适合多用户、高并发和联机交易（OLTP）。只用 InnoDB 支持行级锁。

2. 表级锁

    一次只允许一个会话更新表。

#### 外部锁 ####

可以使用 `lock table` 和 `unlock table` 来控制锁定。

1. read

    当一个表被锁定为 read 是，多个会话可以从表中读取数据，而不需要获取锁。多个会话可以在同一个表上获得锁（也称为 **共享锁**）。当 read 锁被保持时，会用会话可以写入数据（包括当前会话）。

2. write

    当一个表被锁定为 write 时，除了当前会话，其他任何会话都不能读取或者写入数据，直到当前锁被释放（也称为 **排他锁**）。

```bash
LOCK TABLES table_name [READ/WRITE]
...
UNLOCK TABLES
```